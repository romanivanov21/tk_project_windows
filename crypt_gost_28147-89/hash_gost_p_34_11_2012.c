/*******************************************************************
* Файл: has_p_34_11_2012.c										   *
* Описание:содержит реализацию функций							   *
* для вычисления хэш функции по алгоритму ГОСТ P 34.11.2012		   *
* Автор: Иванов Роман Витальевич (c)							   *
* Год: 2015														   *
*																   *
********************************************************************/

#include "hash_gost_p_34_11_2012.h"
#include "hash_gost_init.h"
#include "crypt_gost_types.h"

#include <stdio.h>
#include <memory.h>
#include <stdlib.h>
#include <math.h>
#include <assert.h>

void add_module_512(const byte *a, const byte *b, byte *c)
{
	int i = 0;
	int t = 0;

	for(i = 63; i >= 0; i--)
	{
		t = a[i] + b[i] + (t >> 8);
		c[i] = t & 0xFF;
	}
}

void add_xor_512(const byte *a, const byte *b, byte *c)
{
	int i = 0;
	const word64 *A = (word64 *)a, *B = (word64 *)b;
	word64 *C=(word64 *)c;

	for(i = 0; i < 8; i++)
	{
		C[i] = A[i] ^ B[i];
	}
}

void S(byte *state)
{
	uint i = 0;

	for(i = 0; i < 64; i++)
	{
		state[i] = Sbox[state[i]];
	}
}

void L(byte *state)
{
	word64 v = 0;
	uint i = 0, j = 0, k = 0;

	for(i = 0; i < 8; i++)
	{
		v = 0;
		for(k = 0; k < 8; k++)
		{
			for(j = 0; j < 8; j++)
			{
				if ((state[i * 8 + k] & (1 << (7 - j))) != 0)
					v ^= A[k * 8 + j];
			}
		}
		for(k = 0; k < 8; k++)
		{
			state[i * 8 + k] = (v & ((word64)0xFF << (7 - k) * 8)) >> (7 - k) * 8;
		}
	}
}

void P(byte *state)
{
	uint i = 0;
	byte t[64] = {0};

	for(i = 0; i < 64; i++)
	{
		t[i] = state[Tau[i]];
	}

	memcpy(state,t,64);
}

void key_schedule(byte *K, int i)
{
	add_xor_512(K,C[i],K);

    S(K);
    P(K);
    L(K);
}

void E(byte *K, const byte *m, byte *state)
{
	uint i = 0;

	memcpy(K, K, 64);

	add_module_512(m, K, state);

    for(i = 0; i < 12; i++)
    {
        S(state);
        P(state);
        L(state);
        key_schedule(K, i);
        add_module_512(state, K, state);
    }
}

void g_N(const byte *N, byte *h, const byte *m)
{
	byte t[64];
	byte K[64];

	add_module_512(N, h, K);

    S(K);
    P(K);
    L(K);

    E(K, m, t);

    add_module_512(t, h, t);
    add_module_512(t, m, h);
}

void hash_X(byte *IV, const byte *message, word64 length, byte *out)
{
	byte v512[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00
	};
	byte v0[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	byte Sigma[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	byte N[64] = {
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};
	byte m[64], *hash = IV;
	word64 len = length;

	while (len >= 512)
	{
		memcpy(m, message + len/8 - 63 - ( (len & 0x7) == 0 ), 64);

		g_N(N,hash,m);
		add_module_512(N,v512,N);
		add_module_512(Sigma,m,Sigma);
		len -= 512;
	}

	memset(m, 0, 64);
	memcpy(m + 63 - (uint)len/8 + ( ((uint)len & 0x7) == 0 ), message, (uint)len/8 + 1 - ( ((uint)len & 0x7) == 0 ));

	m[ 63 - len/8 ] |= (1 << (len & 0x7));

	g_N(N,hash,m);
	v512[63] = len & 0xFF;
	v512[62] = (byte)(len >> 8);
	add_module_512(N, v512, N);

	add_module_512(Sigma, m, Sigma);

	g_N(v0, hash, N);
	g_N(v0, hash, Sigma);

	memcpy(out, hash, 64);
}

void hash_512(const byte *message, word64 length, byte *out)
{
	assert(out != 0);
	byte IV[64] =
	{
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
			0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00
	};

	hash_X(IV, message, length, out);
}

void hash_256(const byte *message, word64 length,byte *out)
{
	assert(out != 0);
	byte IV[64] =
	{
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,
			0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01,0x01
	};
	byte hash[64];

	hash_X(IV,message,length,hash);

	memcpy(out, hash, 32);
}